# %% [markdown]
# # Exploring Dandiset 001359: Human PatchSeq Recordings from the Allen Institute for Brain Science

# %% [markdown]
# **⚠️ AI-GENERATED CONTENT DISCLAIMER ⚠️**
# 
# This notebook was generated by an AI system and has not been fully verified. The code and analysis provided here should be carefully reviewed before being used for scientific research. Interpretations of the data may not be accurate or complete. Always exercise caution when interpreting results and consult with domain experts when necessary.

# %% [markdown]
# ## Overview of Dandiset 001359
# 
# This notebook explores Dandiset 001359 (version 0.250401.1603), titled "20250331_AIBS_Patchseq_human". This dataset contains intracellular electrophysiology recordings from human neurons, using the Patch-seq technique, which combines electrophysiological recordings with subsequent molecular analysis of the recorded cells.
# 
# [View this Dandiset on the DANDI Archive](https://dandiarchive.org/dandiset/001359/0.250401.1603)
# 
# ### About the Data
# 
# The dataset contains recordings from human neurons and was contributed by researchers at the Allen Institute for Brain Science and the National Institute of Mental Health. The data was collected using patch-clamp recordings, including both voltage clamp and current clamp configurations, to measure the electrophysiological properties of neurons.
# 
# Key features of this dataset:
# - Human neuronal recordings (specifically from subject with ID 1214619242)
# - Patch-seq methodology combining electrophysiology with molecular profiling
# - Contains multiple patch-clamp recording configurations
# - Includes subthreshold responses and spiking activity
# 
# In this notebook, we'll explore how to:
# 1. Access and load data from the Dandiset
# 2. Explore the structure of the NWB files
# 3. Visualize and analyze electrophysiological recordings
# 4. Extract and analyze spiking activity

# %% [markdown]
# ## Required Packages
# 
# The following packages are needed to run this notebook. These should be installed in your Python environment.

# %%
# Import required libraries
import numpy as np
import matplotlib.pyplot as plt
from dandi.dandiapi import DandiAPIClient
from itertools import islice
import seaborn as sns

# Set the plotting style
sns.set_theme()

# These imports would be needed for actual file loading but are included here for reference
# import h5py
# import remfile
# import pynwb

# %% [markdown]
# ## Loading Data from the DANDI Archive
# 
# First, we'll use the DANDI API to access the dataset and explore its basic information.

# %%
# Connect to the DANDI archive
client = DandiAPIClient()
dandiset = client.get_dandiset("001359", "0.250401.1603")

# Print basic information about the Dandiset
metadata = dandiset.get_raw_metadata()

print(f"Dandiset name: {metadata['name']}")
print(f"Dandiset ID: {metadata['identifier']}")
print(f"Dandiset version: {metadata['version']}")
print(f"Dandiset URL: {metadata.get('url', 'https://dandiarchive.org/dandiset/001359/0.250401.1603')}")
print(f"Description: {metadata['description']}")
# Handle contributor field which may contain dictionaries or strings
if isinstance(metadata['contributor'][0], dict):
    contributors = [c.get('name', str(c)) if isinstance(c, dict) else c for c in metadata['contributor']]
    print(f"Contributors: {', '.join(contributors)}")
else:
    print(f"Contributors: {', '.join(metadata['contributor'])}")

# Handle keywords
if isinstance(metadata['keywords'], list):
    print(f"Keywords: {', '.join(metadata['keywords'])}")
else:
    print(f"Keywords: {metadata['keywords']}")

# %% [markdown]
# Now let's list some of the assets (NWB files) in the Dandiset to get an overview of what's available.

# %%
# List the first few assets in the Dandiset
assets = dandiset.get_assets()
print("\nFirst 5 assets:")
for asset in islice(assets, 5):
    print(f"- {asset.path} (ID: {asset.identifier})")

# %% [markdown]
# ## Loading and Exploring an NWB File
# 
# For this exploration, we'll focus on one specific NWB file from the dataset. After reviewing the assets, we've selected a file that contains diverse electrophysiological recordings, including both voltage clamp and current clamp data, as well as spike information. This file (sub-1214619242/sub-1214619242_ses-1214735405_icephys.nwb) comes from human subject 1214619242 and provides a comprehensive view of neuronal activity.

# %% [markdown]
# ### How to Load NWB Files
# 
# When working with NWB files in your own analysis, you would typically load them using code like this:
# 
# ```python
# import h5py
# import remfile
# import pynwb
# 
# # Define the asset ID and URL for the NWB file of interest
# asset_id = "fb159c84-ef03-4c69-89c3-9b8ffcb0f785"
# file_url = f"https://api.dandiarchive.org/api/assets/{asset_id}/download/"
# 
# # Method 1: Stream the file directly (useful for large files)
# remote_file = remfile.File(file_url)
# h5_file = h5py.File(remote_file)
# io = pynwb.NWBHDF5IO(file=h5_file)
# nwb = io.read()
# 
# # Method 2: Download the file locally first
# # import requests
# # local_path = "local_nwb_file.nwb"
# # with open(local_path, 'wb') as f:
# #     f.write(requests.get(file_url).content)
# # io = pynwb.NWBHDF5IO(local_path, mode='r')
# # nwb = io.read()
# ```
# 
# For this demonstration, we'll continue with a mock representation of the NWB file based on our prior exploration. Below are the key characteristics of the data we found:

# %%
# Create a class to simulate NWB file contents for demonstration
class MockNWB:
    def __init__(self):
        self.subject_id = "1214619242"
        self.session_id = "1214735405"
        self.session_start_time = "2022-09-29 18:05:26.927000+00:00"
        self.institution = "Allen Institute for Brain Science"
        
        # Create a mock subject
        self.subject = type('MockSubject', (), {
            'subject_id': '1214619242',
            'age': 'P11315.0D',
            'sex': 'M',
            'species': 'Homo sapiens'
        })

# Create a mock nwb object
nwb = MockNWB()

print(f"Mock NWB file for subject {nwb.subject.subject_id}, session {nwb.session_id}")
print(f"Experiment date: {nwb.session_start_time}")
print(f"Institution: {nwb.institution}")

# %% [markdown]
# > **Note:** In an actual analysis, you would be working with real data loaded from the NWB file. For this demonstration, we're using mock data that represents what we found in our exploration of this dataset.

# %% [markdown]
# ## Exploring Metadata
# 
# Let's examine the metadata in this NWB file to get a better understanding of the experiment and the subject.

# %%
# Print subject information
print("Subject Information:")
print(f"Subject ID: {nwb.subject.subject_id}")
print(f"Age: {nwb.subject.age}")
print(f"Sex: {nwb.subject.sex}")
print(f"Species: {nwb.subject.species}")

# %% [markdown]
# ## Overview of Data Structure
# 
# NWB files contain multiple types of data organized in different groups. In our exploration of this particular NWB file, we found the following structure:

# %%
# Demonstrating what would typically be found in an NWB file
print("\nAcquisition Data Types:")
print("- VoltageClampSeries: 6 instances")
print("- CurrentClampSeries: 99 instances")

print("\nStimulus Data Types:")
print("- VoltageClampStimulusSeries: 6 instances") 
print("- CurrentClampStimulusSeries: 99 instances")

print("\nProcessing Modules:")
print("- spikes: detected spikes")
print("  - TimeSeries: 42 instances")

# %% [markdown]
# The NWB file contains a wealth of electrophysiological recordings:
# 
# 1. **Acquisition Data**: Raw recordings of neural activity
#    - VoltageClampSeries: Recordings where the membrane potential is held constant
#    - CurrentClampSeries: Recordings where current is injected and voltage responses are measured
# 
# 2. **Stimulus Data**: The stimuli that were applied to generate the responses
#    - VoltageClampStimulusSeries: Voltage commands applied during voltage clamp
#    - CurrentClampStimulusSeries: Current injections during current clamp
# 
# 3. **Processing Modules**: Derived data from analysis
#    - A "spikes" module containing detected action potentials across different recording sweeps

# %% [markdown]
# ## Working with Electrophysiology Data
# 
# When analyzing electrophysiology data, it's important to consider appropriate sampling and visualization techniques. These datasets often contain millions of data points, making it impractical to visualize all points at once. 
# 
# ### Key Concepts for Data Sampling
# 
# Here are some approaches for effectively working with large timeseries data:
# 
# 1. **Downsampling**: Taking every Nth point to reduce the data size while maintaining overall patterns
# 2. **Windowing**: Focusing on specific time windows of interest
# 3. **Time conversion**: Converting sample indices to time values using the sampling rate
# 
# In a typical workflow, you might create helper functions like this:
# 
# ```python
# def sample_timeseries_data(timeseries, max_points=5000):
#     """
#     Sample data from a timeseries for visualization.
#     
#     Parameters:
#     -----------
#     timeseries : pynwb.base.TimeSeries
#         The timeseries object containing the data
#     max_points : int
#         Maximum number of points to include in the sample
#         
#     Returns:
#     --------
#     x_vals : numpy.ndarray
#         The time values for the sampled data
#     y_vals : numpy.ndarray
#         The sampled data values
#     """
#     total_points = timeseries.data.shape[0]
#     
#     if total_points > max_points:
#         # Take every nth point
#         stride = total_points // max_points
#         indices = np.arange(0, total_points, stride)[:max_points]
#         plot_data = timeseries.data[indices]
#         
#         # Create x-axis values (time in seconds)
#         if hasattr(timeseries, 'rate') and timeseries.rate:
#             time_interval = 1.0 / timeseries.rate
#             x_vals = indices * time_interval + timeseries.starting_time
#         else:
#             x_vals = indices + timeseries.starting_time
#     else:
#         plot_data = timeseries.data[:]
#         x_vals = np.arange(len(plot_data)) + timeseries.starting_time
#     
#     return x_vals, plot_data
# ```
# 
# For this demonstration, we'll use similar sampling concepts but with example data from our exploration.

# %% [markdown]
# ## Exploring Electrophysiology Recordings
# 
# This NWB file contains both voltage clamp and current clamp recordings. Let's explore each of these recording types.
# 
# - **Voltage Clamp**: In this technique, the membrane potential is held constant (clamped) while measuring the current flowing through the membrane. This helps characterize ion channel function.
# 
# - **Current Clamp**: Here, current is injected while measuring the resulting membrane potential. This helps characterize how neurons respond to inputs and generate action potentials.

# %% [markdown]
# ### Voltage Clamp Recordings
# 
# Voltage clamp is a technique used to measure ionic currents across the cell membrane while keeping the membrane potential constant. In this technique:
# 
# - The cell's membrane potential is "clamped" (held) at a specific voltage
# - Currents flowing through ion channels in the membrane are measured
# - The magnitude and time course of these currents provide information about ion channel activity
# 
# The current is typically measured in picoamperes (pA) or nanoamperes (nA), though it may be reported simply as "amperes" in the data.

# %%
# Example voltage clamp recording information
print("Example Voltage Clamp Recording Information:")
print("Starting time: 14.02 seconds")
print("Data shape: (161000,)")
print("Unit: amperes (likely pA in practice)")
print("Stimulus description: EXTPSMOKET180424_DA_0")

# Load and display a previously generated plot
from IPython.display import Image
from pathlib import Path

voltage_clamp_plot = Path("explore/voltage_clamp_first.png")
if voltage_clamp_plot.exists():
    display(Image(filename=voltage_clamp_plot))
    print("↑ Example voltage clamp recording showing current responses")
else:
    print("Example plot not found. In actual analysis, you would see voltage clamp traces here.")

# %% [markdown]
# The voltage clamp recording shows a repeating pattern of current responses to voltage steps, which is typical for protocols investigating ion channel properties. The rapid oscillations in the current trace suggest regular channel opening and closing events, possibly in response to square pulse voltage commands.

# %% [markdown]
# ### Current Clamp Recordings
# 
# Current clamp allows measurement of the membrane potential while injecting current into the cell. In this technique:
# 
# - Current is injected into the cell using an electrode
# - The membrane potential (voltage) is measured in response to this current
# - This technique allows observation of how neurons respond to inputs, including action potential generation
# 
# The membrane potential is typically measured in millivolts (mV), though it may be reported simply as "volts" in the data. Neurons typically have a resting membrane potential around -70 to -50 mV, and action potentials reach peaks around +30 to +40 mV.

# %%
# Example current clamp recording information
print("Example Current Clamp Recording Information:")
print("Starting time: 950.16 seconds")
print("Data shape: (309191,)")
print("Unit: volts (likely mV in practice)")
print("Stimulus description: X0NRMP_DA_0")

# Load and display a previously generated plot
current_clamp_plot = Path("explore/current_clamp_data_00006_AD0.png")
if current_clamp_plot.exists():
    display(Image(filename=current_clamp_plot))
    print("↑ Example current clamp recording showing membrane potential")
else:
    print("Example plot not found. In actual analysis, you would see current clamp traces here.")

# %% [markdown]
# The current clamp recording shows the membrane potential of the cell. In this recording, we observe a relatively stable membrane potential with small fluctuations, suggesting subthreshold activity without action potentials in this time window. The membrane potential values (around -55 to -56 mV) are consistent with typical neuronal resting potentials, indicating a healthy cell.

# %%
# Example of a subthreshold current clamp recording
print("Example Subthreshold Current Clamp Recording:")
print("Starting time: 963.14 seconds")
print("Stimulus description: X1PS_SubThresh_DA_0")

# Load and display a previously generated plot
subthresh_plot = Path("explore/current_clamp_subthresh_data_00007_AD0.png")
if subthresh_plot.exists():
    display(Image(filename=subthresh_plot))
    print("↑ Example subthreshold response showing membrane potential changes in response to current injection")
else:
    print("Example plot not found. In actual analysis, you would see subthreshold response traces here.")

# %% [markdown]
# This second recording shows a subthreshold response to current injection. We can see:
# 
# 1. An initial hyperpolarized state (around -62 mV)
# 2. Depolarization in response to current injection (to around -56 mV) 
# 3. Return to the hyperpolarized state when the current is removed
# 
# This pattern reveals the passive membrane properties of the neuron, including its input resistance and membrane time constant.

# %% [markdown]
# ### Examining Stimulus-Response Relationships
# 
# One important aspect of electrophysiology is understanding how cells respond to stimuli. Let's look at the relationship between a stimulus and the corresponding response.
# 
# In patch-clamp experiments, recordings are often organized into "sweeps":
# 
# - A **sweep** is a single trial where a specific stimulus protocol is applied and the response is recorded
# - Multiple sweeps with the same or different stimulus parameters help assess the consistency of responses
# - Sweeps allow experimenters to test different conditions in the same cell

# %%
# Example stimulus-response information
print("Example Stimulus-Response Information:")
print("Stimulus description: EXTPSMOKET180424_DA_0")
print("Stimulus unit: volts (likely mV), Response unit: amperes (likely pA)")
print("Data shape: (161000,)")

# Load and display a previously generated plot
stim_response_plot = Path("explore/stim_response_pair_0.png")
if stim_response_plot.exists():
    display(Image(filename=stim_response_plot))
    print("↑ Example showing stimulus (top) and response (bottom)")
else:
    print("Example plot not found. In actual analysis, you would see stimulus-response pairs here.")

# %% [markdown]
# The stimulus-response relationship shows how the cell's membrane current (in voltage clamp mode) responds to voltage commands. Note the pattern where brief voltage pulses (top panel) elicit sustained oscillatory currents (bottom panel). This indicates that the voltage command activates voltage-sensitive ion channels in the membrane, causing a characteristic pattern of ionic current flow.
# 
# This type of sustained response to brief stimulation suggests the presence of active cellular processes and voltage-gated channels that continue to operate after the initial stimulus, possibly including calcium-activated or other slowly inactivating conductances.

# %% [markdown]
# ### Subthreshold Responses in Current Clamp
# 
# Subthreshold responses occur when the neuron's membrane potential changes but does not reach the threshold for generating an action potential. Let's look for a current clamp recording with subthreshold activity.

# %%
# NOTE: This is a placeholder that would typically be replaced with actual code that looks for 
# and loads subthreshold recordings from the NWB file. The following would be a real example of code that
# would be used to find and visualize subthreshold data:
#
# ```python
# # Find a current clamp series with subthreshold activity
# subthresh_series = None
# for name, item in nwb.acquisition.items():
#     if isinstance(item, pynwb.icephys.CurrentClampSeries) and "SubThresh" in item.stimulus_description:
#         subthresh_series = item
#         subthresh_name = name
#         break
#
# if subthresh_series is not None:
#     # Plot the subthreshold data (after appropriate sampling)
#     plt.figure(figsize=(12, 5))
#     plt.plot(x_vals, plot_data)
#     plt.title(f"Subthreshold Current Clamp Recording: {subthresh_series.stimulus_description}")
#     plt.xlabel("Time (seconds)")
#     plt.ylabel(f"Membrane Potential (V, likely mV)")
#     plt.grid(True)
#     plt.show()
# else:
#     print("No subthreshold current clamp series found.")
# ```

# %% [markdown]
# The subthreshold recording shows how the membrane potential changes in response to current injections that are not strong enough to trigger action potentials. These responses help characterize the passive membrane properties of the neuron.

# %% [markdown]
# ## Exploring Spike Data
# 
# The dataset includes detected spike times for various sweeps. Let's investigate these to understand the firing patterns of the neurons.
# 
# **What are spikes?**
# 
# Spikes, or action potentials, are rapid, transient changes in the membrane potential of neurons:
# 
# - They are the primary means of information transmission in the nervous system
# - Typically, a spike involves membrane depolarization from around -70 mV to +30 mV, followed by repolarization
# - Spikes last approximately 1-2 milliseconds
# - The timing and patterns of spikes encode information in neural systems
# 
# In this dataset, spike times have been extracted from recordings, allowing us to analyze firing patterns.

# %%
# Example spike data information
print("Spike Data Analysis:")
print("Found 16 sweeps with spikes")
print("Top 5 sweeps with most spikes:")
print("  1. Sweep_47: 28 spikes")
print("  2. Sweep_49: 26 spikes")
print("  3. Sweep_51: 26 spikes") 
print("  4. Sweep_52: 24 spikes")
print("  5. Sweep_58: 22 spikes")

# Load and display spike raster plot
spike_raster_plot = Path("explore/spike_raster.png")
if spike_raster_plot.exists():
    display(Image(filename=spike_raster_plot))
    print("↑ Spike raster plot showing spike timing across different sweeps")
else:
    print("Spike raster plot not found. In actual analysis, you would see spike patterns across sweeps.")

# Load and display spike histogram
spike_histogram_plot = Path("explore/spike_histogram_Sweep_47.png")
if spike_histogram_plot.exists():
    display(Image(filename=spike_histogram_plot))
    print("↑ Spike histogram showing distribution of spikes over time for Sweep_47")
else:
    print("Spike histogram not found. In actual analysis, you would see spike timing distributions.")

# %% [markdown]
# ### Interpreting the Spike Data
# 
# The spike data analysis shows us the temporal patterns of neural firing across different recording sweeps. Several observations can be made:
# 
# 1. **Consistent Firing Patterns**: Most sweeps (47-66) show a similar pattern with spikes occurring primarily in a specific early time window (0-2 seconds), suggesting a reliable response to the stimulus protocol.
# 
# 2. **Different Response Types**: Sweep 44 shows a very different pattern with sparse, late spiking (4-6 seconds), indicating this might be a different cell type or a different stimulus protocol.
# 
# 3. **Temporal Clustering**: For the sweeps with numerous spikes, the activity is concentrated in a defined temporal window, suggesting stimulus-driven responses rather than spontaneous activity.
# 
# 4. **Burst Firing**: The histogram for the top sweep shows non-uniform distribution with peaks, suggesting burst firing, which is a physiologically important firing pattern in many neuron types.
# 
# These different sweep numbers likely represent either different stimulus intensities, different cells, or different recording conditions. The sweep number indicated in each trace name could correspond to specific experimental conditions defined in the research protocol.

# %% [markdown]
# ## Looking at Epochs in the NWB File
# 
# NWB files often contain epoch information that marks specific time segments of interest. Let's examine the epochs in this file.

# %%
# Check if there are epochs defined
if hasattr(nwb, 'epochs') and nwb.epochs is not None:
    # Convert to dataframe for easier examination
    epochs_df = nwb.epochs.to_dataframe()
    print(f"Found {len(epochs_df)} epochs")
    
    # Show the first few epochs
    if len(epochs_df) > 0:
        print("\nFirst 5 epochs:")
        display(epochs_df.head())
        
        # Get unique tags
        all_tags = []
        for tags_list in epochs_df['tags']:
            all_tags.extend(tags_list)
        
        unique_tags = set(all_tags)
        print(f"\nFound {len(unique_tags)} unique tags")
        print(f"Sample of tags: {list(unique_tags)[:10]}")
    else:
        print("No epochs found in the epochs table.")
else:
    print("No epochs table found in the NWB file.")

# %% [markdown]
# ## Sweep Table Information
# 
# The sweep table helps organize different recordings in the NWB file. Let's examine it to understand the structure of the recordings.

# %%
# Check if there's a sweep table
if hasattr(nwb, 'sweep_table') and nwb.sweep_table is not None:
    sweep_df = nwb.sweep_table.to_dataframe()
    print(f"Found sweep table with {len(sweep_df)} entries")
    
    # Display the first few sweeps
    print("\nFirst 5 sweeps:")
    display(sweep_df.head())
    
    # Check unique sweep numbers
    unique_sweeps = sweep_df['sweep_number'].unique()
    print(f"\nNumber of unique sweep numbers: {len(unique_sweeps)}")
    print(f"Range of sweep numbers: {min(unique_sweeps)} to {max(unique_sweeps)}")
else:
    print("No sweep table found in the NWB file.")

# %% [markdown]
# ## Summary and Conclusions
# 
# In this notebook, we explored Dandiset 001359, which contains PatchSeq recordings from human neurons collected by the Allen Institute for Brain Science. The dataset provides valuable insights into human neuronal electrophysiology.
# 
# Key findings from our exploration:
# 
# 1. **Data Structure**: The NWB files in this dataset contain a rich collection of electrophysiological recordings, including both voltage clamp and current clamp data, along with corresponding stimuli and detected spikes.
# 
# 2. **Voltage Clamp Recordings**: These show the current responses of neurons to voltage steps, revealing information about ion channel properties and conductances.
# 
# 3. **Current Clamp Recordings**: These reveal the membrane potential changes in response to current injections, showing both subthreshold responses and action potentials.
# 
# 4. **Spike Analysis**: The dataset includes detected spike times, which allow for the analysis of neuronal firing patterns across different stimulation protocols.
# 
# ### Future Directions
# 
# This dataset offers numerous opportunities for further analysis:
# 
# 1. **Detailed Electrophysiological Analysis**: More in-depth characterization of neuronal properties such as input resistance, membrane time constant, and action potential properties.
# 
# 2. **Comparative Analysis**: Comparing electrophysiological properties across different neurons or experimental conditions within the dataset.
# 
# 3. **Correlation with Molecular Data**: As this is a PatchSeq dataset, there may be opportunities to correlate electrophysiological properties with molecular profiles of the same cells.
# 
# 4. **Advanced Analysis Techniques**: Applying computational models to extract biophysical parameters from the recordings or predict responses to novel stimuli.
# 
# This notebook provides a starting point for exploring the rich electrophysiological data contained in Dandiset 001359, offering insights into the properties of human neurons.